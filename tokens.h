//***************************************************************************
//	NARS2000 -- Tokens
//***************************************************************************

/***************************************************************************
	NARS2000 -- An Experimental APL Interpreter
	Copyright (C) 2006-2008 Sudley Place Software

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
***************************************************************************/

/*

Tokens are containers  for all sorts of objects such as operators,
functions, variables, grouping symbols, lists, list separators, etc.

Most tokens are simple in that they have type and data only.e,g,
TKT_LPAREN and '('.  Some tokens are complex in that their data
points to other data.

The following tokens are complex:

TKT_VARNAMED This container's tkData is an LPSYMENTRY which names
			a variable.  The LPSYMENTRY may be immediate or not.
			If the latter, stData contains an HGLOBAL which points
			to a simple or nested or hetero array.

TKT_VARIMMED This container's tkData is one of Boolean, Integer,
			Floating Point, or Character as distinguished by
			the value in tkFlags.ImmType.

TKT_LISTBR	This container's tkData points to an HGLOBAL which
			contains a list array in global memory.

TKT_VARARRAY The main workhorse.  Its tkData is an HGLOBAL which
			contains an array which is either simple, nested, or
			hetero.

TKT_STRAND	Valid only during strand processing after which it
			is converted to TKT_VARARRAY.

TKT_STRING	Valid only during strand processing after which it
			is converted to TKT_VARARRAY.

Outside strand processing, only the tokens TKT_VARNAMED, TKT_VARIMMED,
TKT_LIST, and TKT_VARARRAY are present in a token which points to a
value.

 */

// Data Token Types
#define TKT_FIRST 1 		// This way, we can catch uninitialized
							//	 token types (i.e., .TknType EQ 0)
typedef enum tagTOKEN_TYPES
{TKT_VARNAMED = TKT_FIRST,	// 01: Symbol table entry for a named var (data is LPSYMENTRY)
 TKT_STRING   , 			// 02: String  (data is HGLOBAL)
 TKT_VARIMMED , 			// 03: An immediate constant (Boolean, Integer, Character, or Floating point,
							//	   distinguished by the value in tkFlags.ImmType)
 TKT_COMMENT  , 			// 04: Comment (data is NULL)
 TKT_ASSIGN   , 			// 05: Assignment symbol (data is UTF16_LEFTARROW)
 TKT_LISTSEP  , 			// 06: List separator	 (data is ';')
 TKT_LABELSEP , 			// 07: Label separator	 (data is ':')
 TKT_COLON	  , 			// 08: Colon			 (data is ':')
 TKT_FCNIMMED , 			// 09: An immediate primitive function (data is UTF16_***)
 TKT_OP1IMMED , 			// 0A: An immediate monadic primitive operator (data is UTF16_***)
 TKT_OP2IMMED , 			// 0B: ...			dyadic	...
 TKT_OP3IMMED , 			// 0C: ...			ambiguous  ...
 TKT_OPJOTDOT , 			// 0D: Outer product monadic operator (with right scope) (data is NULL)
 TKT_LPAREN   , 			// 0E: Left paren (data is TKT_LPAREN)
 TKT_RPAREN   , 			// 0F: Right ...   ...		   RPAREN
 TKT_LBRACKET , 			// 10: Left bracket ... 	   LBRACKET
 TKT_RBRACKET , 			// 11: Right ...   ...		   RBRACKET
 TKT_EOS	  , 			// 12: End-of-Stmt (data is length of stmt including this token)
 TKT_EOL	  , 			// 13: End-of-Line	...
 TKT_SOS	  , 			// 14: Start-of-Stmt (data is NULL)
 TKT_LINECONT , 			// 15: Line continuation (data is NULL)
 TKT_INPOUT   , 			// 16: Input/Output (data is UTF16_QUAD or UTF16_QUOTEQUAD symbol)

 TKT_LENGTHp1 , 			// 17: Last token type

 // These token types are not generated by <Tokenize_EM>
 //   hence, they never appear in a saved token stream,
 //   only as a parse token created during <ParseLine>.
 TKT_STRAND = TKT_LENGTHp1, // 17: Strand accumulating (data is LPTOKEN)
 TKT_LISTINT  , 			// 18: List intermediate (data is HGLOBAL)
 TKT_LISTPAR  , 			// 19: List in parens	 (data is HGLOBAL)
 TKT_LISTBR   , 			// 1A: List in brackets  (data is HGLOBAL)
 TKT_VARARRAY , 			// 1B: Array of data (data is HGLOBAL)
 TKT_FCNARRAY , 			// 1C: Array of functions and/or operators (data is HGLOBAL)
 TKT_FCNNAMED , 			// 1D: A named function (data is LPSYMENTRY)
 TKT_AXISIMMED, 			// 1E: An immediate axis specification (data is immediate)
 TKT_AXISARRAY, 			// 1F: An array of	...   (data is HGLOBAL)
 TKT_OP1NAMED , 			// 20: A named monadic primitive operator (data is LPSYMENTRY)
 TKT_OP2NAMED , 			// 21: ...	   dyadic  ...
 TKT_OP3NAMED , 			// 22: ...	   ambiguous ...
 TKT_STRNAMED , 			// 23: A named strand
							// 24-3F:  Available entries (6 bits)
} TOKEN_TYPES;

#define TKT_LENGTH		(TKT_LENGTHp1 - 1)

// N.B.:  Whenever changing the above enum (TOKEN_TYPES),
//	 be sure to make a corresponding change to
//	 <Untokenize> in <tokenize.c>,
//	 <LookaheadAdjacent>, <LookaheadDyadicOp>, and <pl_yylex> in <parse.y>,
//	 <MakeVarStrand_EM_YY> in <strand.c>,
//	 <GetTokenTypeName> in <dispdbg.c>,
//	 and <TokenTypeFV> in <primfns.c>.


typedef struct tagTKFLAGS
{
	UINT TknType:6, 		// 0000003F:  Data token type (see TOKEN_TYPES)
		 Align:2,			// 000000C0:  Alignment bits (available if necessary)
		 ImmType:4, 		// 00000F00:  Type of immediate data (see IMM_TYPES) (if .Type is TKT_VARIMMED/TKT_FCNIMMED)
		 NoDisplay:1,		// 00000000:  Do not display this token
		 Avail:19;			// FFFFE000:  Available bits
} TKFLAGS, *LPTKFLAGS;

typedef union tagTOKEN_DATA
{
	struct tagSYMENTRY *tkSym;		// 00:	Data is an LPSYMENTRY
	HGLOBAL    tkGlbData;			// 00:	... 	an HGLOBAL
	UINT	   tkIndex; 			// 00:	... 	an index
	APLBOOL    tkBoolean;			// 00:	... 	an APLBOOL
	APLINT	   tkInteger;			// 00:	... 	an APLINT
	APLFLOAT   tkFloat; 			// 00:	... 	a floating point number
	APLCHAR    tkChar;				// 00:	... 	an APLCHAR
	LPVOID	   tkVoid;				// 00:	... 	an abritrary ptr
	APLLONGEST tkLongest;			// 00:	Longest datatype (so we can copy the entire data)
									// 08:	Length
} TOKEN_DATA, *LPTOKEN_DATA;

typedef struct tagTOKEN
{
	TKFLAGS 		 tkFlags;		// 00:	The flags part
	TOKEN_DATA		 tkData;		// 04:	The data part
	int 			 tkCharIndex;	// 0C:	Index into the input line of this token
	struct tagTOKEN *lptkOrig;		// 10:	Ptr to original token
									// 14:	Length
} TOKEN, *LPTOKEN;

#define TOKEN_HEADER_SIGNATURE		'NKOT'

typedef struct tagTOKEN_HEADER
{
	HEADER_SIGNATURE Sig;			// 00:	Token header signature
	UINT			 Version,		// 04:	Version # of this header
					 TokenCnt,		// 08:	# tokens in lpToken
					 PrevGroup; 	// 0C:	Index of the previous (to the left) grouping symbol
									//		(L/R paren, L/R bracket) where the index is relative
									//		to the first token after this header.
									// 10:	Length
									// 10:	Followed by a <TokenCnt> array of TOKENs
} TOKEN_HEADER, *LPTOKEN_HEADER;

#define TokenBaseToStart(base)	(LPTOKEN) (((LPCHAR) base) + sizeof (TOKEN_HEADER))

typedef union tagUNION_TOKEN
{
	LPTOKEN 	   lpBase;			// 00:	Locked base of hGlbToken
	LPTOKEN_HEADER lpHeader;		// 00:	Token header
									// 04:	Length
} UNION_TOKEN, *LPUNION_TOKEN;


#define FSA_EXIT	   -1		// FSA is done
#define FSA_NONCE	   -2		// State not specified as yet
#define FSA_SYNTERR    -3		// A SYNTAX ERROR has occurred


//***************************************************************************
//	End of File: tokens.h
//***************************************************************************
